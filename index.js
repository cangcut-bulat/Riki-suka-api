require('dotenv').config(); // <-- Pastikan ini paling atas

const express = require('express');
const chalk = require('chalk');
const fs = require('fs');
const cors = require('cors');
const path = require('path');
const moment = require('moment-timezone');
const axios = require('axios');
const crypto = require('crypto'); // Dibutuhkan untuk generate key

// --- Log Warna Kustom ---
const log = { info: (...args) => console.log(chalk.blueBright(...args)), warn: (...args) => console.warn(chalk.yellow(...args)), error: (...args) => console.error(chalk.red(...args)), req: (...args) => console.log(chalk.cyan(...args)), limit: (...args) => console.log(chalk.magenta(...args)), admin: (...args) => console.log(chalk.blue(...args)), ipLog: (...args) => console.log(chalk.green(...args)), customKey: (...args) => console.log(chalk.hex('#FFA500')(...args)), ddos: (...args) => console.error(chalk.bgRed.white(...args)), notify: (...args) => console.log(chalk.magentaBright(...args)) };
log.info("LOG: Script index.js dimulai.");

// --- Baca Konfigurasi dari Environment ---
const ADMIN_API_KEY = process.env.ADMIN_KEY;
const ADMIN_PAGE_PASSWORD = process.env.ADMIN_PAGE_PASSWORD;
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID;
const INITIAL_DAILY_LIMIT = parseInt(process.env.DAILY_LIMIT, 10) || 100;
const FLOOD_WINDOW_SECONDS = parseInt(process.env.FLOOD_WINDOW_SECONDS, 10) || 10;
const FLOOD_LIMIT_PER_WINDOW = parseInt(process.env.FLOOD_LIMIT_PER_WINDOW, 10) || 50;
const FLOOD_DETECTION_ENABLED = (process.env.FLOOD_DETECTION_ENABLED || 'true') === 'true';
const MAX_NOTIFICATIONS = 50;

if (!ADMIN_API_KEY) log.warn("PERINGATAN: 'ADMIN_KEY' tidak diatur.");
if (!ADMIN_PAGE_PASSWORD) log.warn("PERINGATAN: 'ADMIN_PAGE_PASSWORD' (untuk login) tidak diatur.");
if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) log.warn("PERINGATAN: Telegram tidak dikonfigurasi.");

// --- Fungsi utilitas ---
function calculateNextResetTime() { return moment().tz('Asia/Jakarta').endOf('day').add(1, 'millisecond').valueOf(); }
async function sendTelegramNotification(message) { if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) return; const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`; try { await axios.post(url, { chat_id: TELEGRAM_CHAT_ID, text: message, parse_mode: 'HTML' }, { timeout: 5000 }); } catch (error) { log.error("Gagal kirim notif Telegram:", error.response?.data?.description || error.message); } }
async function sendDdosNotification(ip) { if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) return; const message = `ğŸš¨ <b>!!! PERINGATAN DDOS/FLOOD !!!</b> ğŸš¨\nâ€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\nğŸ›¡ï¸ <b>Tindakan:</b> IP Telah Diblokir Otomatis.\nğŸ¯ <b>IP Target:</b> <code>${ip}</code>\nğŸ“ˆ <b>Request Rate:</b> > ${FLOOD_LIMIT_PER_WINDOW} req / ${FLOOD_WINDOW_SECONDS} dtk.`; const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`; try { await axios.post(url, { chat_id: TELEGRAM_CHAT_ID, text: message.replace(/^\s+/gm, ''), parse_mode: 'HTML' }, { timeout: 5000 }); } catch (error) { log.error("Gagal kirim notif DDoS Telegram:", error.response?.data?.description || error.message); } }

// [MODIFIKASI] Fungsi untuk masking IP
function maskIp(ip) {
    if (!ip || typeof ip !== 'string') return '?.?.?.?';
    // Cek apakah IPv4
    if (ip.includes('.')) {
        const parts = ip.split('.');
        if (parts.length === 4) {
            return `${parts[0]}.${parts[1]}.*.*`;
        }
    }
    // Cek apakah IPv6 (sederhana, bisa disesuaikan)
    if (ip.includes(':')) {
         const parts = ip.split(':');
         // Ambil 2 bagian pertama, sisanya mask
         if (parts.length >= 2) {
             return `${parts[0]}:${parts[1]}::****`;
         }
    }
    // Jika format tidak dikenali, kembalikan sebagian
    return ip.substring(0, Math.min(ip.length, 5)) + '...';
}

// Fungsi runtime
if (typeof runtime !== 'function') { global.startTime = Date.now(); global.runtime = function() { const uptimeMilliseconds = Date.now() - global.startTime; const seconds = Math.floor((uptimeMilliseconds / 1000) % 60); const minutes = Math.floor((uptimeMilliseconds / (1000 * 60)) % 60); const hours = Math.floor((uptimeMilliseconds / (1000 * 60 * 60)) % 24); const days = Math.floor(uptimeMilliseconds / (1000 * 60 * 60 * 24)); let result = ''; if (days > 0) result += days + 'd '; if (hours > 0) result += hours + 'h '; if (minutes > 0) result += minutes + 'm '; result += seconds + 's'; return result.trim(); }; log.info("LOG: Fungsi 'runtime' ditambahkan secara internal."); }
else { global.startTime = Date.now(); log.info("LOG: Fungsi 'runtime' sudah ada."); }
try { require("./function.js"); log.info("LOG: function.js dimuat (jika ada)."); } catch (e) { if (e.code === 'MODULE_NOT_FOUND') { log.warn("PERINGATAN: function.js tidak ditemukan."); } else { log.error("FATAL ERROR load function.js:", e.message); process.exit(1); } }

const app = express();
const PORT = process.env.SERVER_PORT || process.env.PORT || 8000;
log.info(`LOG: Port: ${PORT}`); log.info(`LOG: Anti-Flood: ${FLOOD_DETECTION_ENABLED ? `ON (${FLOOD_LIMIT_PER_WINDOW} req / ${FLOOD_WINDOW_SECONDS}s)` : 'OFF'}`);
app.enable("trust proxy"); app.set("json spaces", 2); app.use(express.json()); app.use(express.urlencoded({ extended: false })); app.use(cors()); log.info("LOG: Middleware dasar dimuat.");

// --- Lokasi File ---
const API_PAGE_DIR = path.join(__dirname, 'api-page'); const ROOT_DIR = __dirname; const error404Path = path.join(API_PAGE_DIR, '404.html'); const error500Path = path.join(API_PAGE_DIR, '500.html'); const blacklistFilePath = path.join(ROOT_DIR, 'blacklist.json'); const rateLimitsFilePath = path.join(ROOT_DIR, 'rate_limits.json'); const uniqueIpsFilePath = path.join(ROOT_DIR, 'unique_ips.json'); const customKeysFilePath = path.join(ROOT_DIR, 'api_keys.json'); const apiKeyOverridesFilePath = path.join(ROOT_DIR, 'apikey_requirements.json'); const notificationsFilePath = path.join(ROOT_DIR, 'notifications.json');

// Static file serving
app.use(express.static(API_PAGE_DIR)); app.use(express.static(ROOT_DIR)); app.use('/images', express.static(path.join(ROOT_DIR, 'images'))); app.use('/audio', express.static(path.join(ROOT_DIR, 'audio'))); log.info("LOG: Penyajian file statis dikonfigurasi.");

// --- Data & Fungsi Persistence ---
let rateLimitData = {}; let ipRequestLog = {}; global.ipBlacklist = new Set(); global.uniqueIps = new Set(); global.notifications = [];
global.customApiKeys = {}; global.apiKeyOverrides = {}; global.currentDailyLimit = INITIAL_DAILY_LIMIT; global.isRateLimitingEnabled = true; global.totalreq = 0;

// Fungsi helper baca/tulis JSON
function readJsonFile(filePath, defaultValue) { try { if (fs.existsSync(filePath)) { const fileContent = fs.readFileSync(filePath, 'utf-8'); if (!fileContent) return defaultValue; const jsonData = JSON.parse(fileContent); if (typeof defaultValue === 'object' && defaultValue !== null && !Array.isArray(defaultValue)) { return (typeof jsonData === 'object' && jsonData !== null && !Array.isArray(jsonData)) ? jsonData : defaultValue; } if (Array.isArray(defaultValue)) { return Array.isArray(jsonData) ? jsonData : defaultValue; } return jsonData || defaultValue; } } catch (err) { log.error(`ERROR load ${path.basename(filePath)}:`, err); if (err instanceof SyntaxError) { const backupPath = filePath + '.bak'; try { fs.copyFileSync(filePath, backupPath); log.warn(`WARNING: File ${path.basename(filePath)} rusak, backup dibuat di ${backupPath}`); fs.writeFileSync(filePath, JSON.stringify(defaultValue, null, 2), 'utf-8'); log.warn(`WARNING: File ${path.basename(filePath)} direset ke default.`); return defaultValue; } catch (backupErr) { log.error(`ERROR saat mencoba backup/reset ${path.basename(filePath)}:`, backupErr); } } } return defaultValue; }
function writeJsonFile(filePath, data) { try { fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf-8'); } catch (err) { log.error(`ERROR save ${path.basename(filePath)}:`, err); } }

// Load/Save Functions
function loadBlacklist() { const ips = readJsonFile(blacklistFilePath, []); if (Array.isArray(ips)) global.ipBlacklist = new Set(ips); log.admin(`LOG: Blacklist dimuat (${global.ipBlacklist.size} IP).`); }
function saveBlacklist() { writeJsonFile(blacklistFilePath, Array.from(global.ipBlacklist).sort()); }
function loadRateLimits() { rateLimitData = readJsonFile(rateLimitsFilePath, {}); log.info(`LOG: Rate limit dimuat (${Object.keys(rateLimitData).length} IP).`); if(typeof rateLimitData !== 'object' || rateLimitData === null) rateLimitData = {}; }
function saveRateLimits() { writeJsonFile(rateLimitsFilePath, rateLimitData); }
function loadUniqueIps() { const ips = readJsonFile(uniqueIpsFilePath, []); if (Array.isArray(ips)) global.uniqueIps = new Set(ips); log.info(`LOG: IP unik dimuat (${global.uniqueIps.size} IP).`); }
function saveUniqueIps() { writeJsonFile(uniqueIpsFilePath, Array.from(global.uniqueIps).sort()); }
function loadCustomApiKeys() { global.customApiKeys = readJsonFile(customKeysFilePath, {}); log.info(`LOG: Kunci API Kustom dimuat (${Object.keys(global.customApiKeys).length} kunci).`); if(typeof global.customApiKeys !== 'object' || global.customApiKeys === null) global.customApiKeys = {}; }
function saveCustomApiKeys() { writeJsonFile(customKeysFilePath, global.customApiKeys); }
function loadApiKeyOverrides() { global.apiKeyOverrides = readJsonFile(apiKeyOverridesFilePath, {}); log.admin(`LOG: Override API Key dimuat (${Object.keys(global.apiKeyOverrides).length} aturan).`); if(typeof global.apiKeyOverrides !== 'object' || global.apiKeyOverrides === null) global.apiKeyOverrides = {}; }
function saveApiKeyOverrides() { writeJsonFile(apiKeyOverridesFilePath, global.apiKeyOverrides); }

// Fungsi Notifikasi
let notificationIdCounter = 0;
function addNotification(type, message, icon = 'info-circle') { const newNotif = { id: ++notificationIdCounter, timestamp: Date.now(), type: type, message: message, icon: icon, read: false }; global.notifications.unshift(newNotif); if (global.notifications.length > MAX_NOTIFICATIONS) { global.notifications.pop(); } log.notify(`NOTIF [${type}]: ${message}`); }

// Muat semua data saat start
loadBlacklist(); loadRateLimits(); loadUniqueIps(); loadCustomApiKeys(); loadApiKeyOverrides();
log.info(`LOG: Rate limit IP default: ${global.currentDailyLimit}, Status: ${global.isRateLimitingEnabled ? 'ON' : 'OFF'}.`);

// --- Middleware 1: Flood/DDoS & Blacklist ---
app.use((req, res, next) => { const ip = req.ip; const now = Date.now(); if (FLOOD_DETECTION_ENABLED) { if (!ipRequestLog[ip]) ipRequestLog[ip] = []; ipRequestLog[ip].push(now); const windowStart = now - (FLOOD_WINDOW_SECONDS * 1000); ipRequestLog[ip] = ipRequestLog[ip].filter(ts => ts >= windowStart); if (ipRequestLog[ip].length > FLOOD_LIMIT_PER_WINDOW) { if (!global.ipBlacklist.has(ip)) { log.ddos(`ğŸš¨ DDOS DETECTED: IP ${ip} diblokir! (${ipRequestLog[ip].length} reqs / ${FLOOD_WINDOW_SECONDS}s)`); global.ipBlacklist.add(ip); saveBlacklist(); sendDdosNotification(ip); addNotification('system', `IP ${maskIp(ip)} diblokir otomatis (flood).`, 'shield-alt'); } else { log.warn(`BLACKLIST: Tolak IP (flood): ${ip}`); } return res.status(429).json({ status: false, error: "Terlalu banyak request. IP Anda diblokir sementara." }); } } if (global.ipBlacklist.has(ip)) { log.warn(`BLACKLIST: Tolak IP: ${ip}`); return res.status(403).json({ status: false, error: "Akses ditolak (IP diblokir)." }); } next(); });
log.info("LOG: Middleware 1 (DDoS, Blacklist) dimuat.");

// --- Load settings.json ---
const settingsPath = path.join(__dirname, './settings.json');
global.settings = {}; global.endpointStatus = {}; global.dynamicLabels = {}; global.initialRequiredKeyPaths = new Set();
try { global.settings = readJsonFile(settingsPath, {}); for (const category in global.settings.endpoints) { if (Array.isArray(global.settings.endpoints[category])) { global.settings.endpoints[category].forEach(e => { if (e.path) { const basePath = e.path.split('?')[0]; global.endpointStatus[basePath] = e.status || 'Active'; if (e.path.includes('apikey=')) { global.initialRequiredKeyPaths.add(basePath); } } }); } } log.info("LOG: settings.json dibaca, var global siap."); log.admin(`LOG: Path Awal Wajib API Key (dari settings.json): ${global.initialRequiredKeyPaths.size} endpoint.`); } catch (err) { log.error(`FATAL ERROR: Gagal memuat settings.json: ${err.message}`); process.exit(1); }

// --- Logika global.apikey ---
global.apikey = global.settings.apikey || []; log.info(`LOG: Kunci default dimuat: ${global.apikey.length}`); const customKeys = Object.keys(global.customApiKeys); if (customKeys.length > 0) { global.apikey = global.apikey.concat(customKeys); log.info(`LOG: Menggabungkan ${customKeys.length} Kunci Kustom ke global.apikey.`); } if (!global.apikey.includes(undefined)) { global.apikey.push(undefined); } log.admin(`LOG: Total global.apikey (termasuk custom & undefined): ${global.apikey.length}`);

// --- Middleware 2: Logika Utama (Limit IP & Validasi API Key & IP Unik) ---
app.use((req, res, next) => {
    const ip = req.ip; const reqPath = req.path; const now = Date.now();
    const excludedPaths = ['/', '/api/stats', '/api/my-stats', '/api/endpoint-status', '/api/get-endpoints', '/api/public/blacklist', '/api/checkapikey', '/api/notifications']; const excludedPrefixes = ['/images/', '/audio/', '/api/admin/']; const excludedSuffixes = ['.html', '.css', '.js', '.png', '.jpg', '.jpeg', '.gif', '.ico', '.map', '.woff', '.woff2', '.ttf', '.svg']; let isExcluded = excludedPaths.includes(reqPath) || excludedPrefixes.some(p => reqPath.startsWith(p)) || excludedSuffixes.some(s => reqPath.endsWith(s)); if (reqPath === '/admin' || (reqPath === '/' && req.method === 'GET' && req.accepts('html'))) { isExcluded = true; }
    if (isExcluded) return next();

    log.req(`LOG: Request dari IP: ${ip} ke ${reqPath}`); global.totalreq += 1;
    const providedKey = req.query.apikey; let useIpLimit = true; let limitInfo = ''; let keyName = 'IP Limit';
    const pathOverride = global.apiKeyOverrides[reqPath]; let needsKey; if (pathOverride !== undefined) { needsKey = pathOverride; } else { needsKey = global.initialRequiredKeyPaths.has(reqPath); }

    if (needsKey) { if (providedKey) { const customKeyData = global.customApiKeys[providedKey]; if (customKeyData) { keyName = customKeyData.name || providedKey; if (customKeyData.expires && now >= customKeyData.expires) { log.warn(`CUSTOM KEY: Kunci '${keyName}' KEDALUWARSA.`); return res.status(403).json({ status: false, error: "Kunci API Kustom Anda telah kedaluwarsa." }); } if (customKeyData.limit > 0 && (customKeyData.count || 0) >= customKeyData.limit) { log.warn(`CUSTOM KEY: Kunci '${keyName}' LIMIT HABIS.`); return res.status(403).json({ status: false, error: "Limit Kunci API Kustom Anda telah habis." }); } log.customKey(`CUSTOM KEY: Kunci '${keyName}' VALID.`); useIpLimit = false; customKeyData.count = (customKeyData.count || 0) + 1; saveCustomApiKeys(); limitInfo = `ğŸ”‘ <b>Key (${keyName}):</b> ${customKeyData.count} / ${customKeyData.limit || 'âˆ'}`; } else if (global.settings.apikey && global.settings.apikey.includes(providedKey)) { keyName = 'Default Key'; } else { log.warn(`API KEY: Kunci '${providedKey}' TIDAK VALID.`); } } }
    else { if (providedKey && global.customApiKeys[providedKey]) { const customKeyData = global.customApiKeys[providedKey]; keyName = customKeyData.name || providedKey; if (!(customKeyData.expires && now >= customKeyData.expires) && !(customKeyData.limit > 0 && (customKeyData.count || 0) >= customKeyData.limit)) { log.customKey(`CUSTOM KEY: Kunci '${keyName}' VALID (opsional di endpoint publik).`); useIpLimit = false; customKeyData.count = (customKeyData.count || 0) + 1; saveCustomApiKeys(); limitInfo = `ğŸ”‘ <b>Key (${keyName}):</b> ${customKeyData.count} / ${customKeyData.limit || 'âˆ'}`; } else { log.warn(`CUSTOM KEY: Kunci '${keyName}' expired/limit habis di endpoint publik (dialihkan ke IP Limit).`); } } }

    if (useIpLimit) { if (global.isRateLimitingEnabled) { let ipData = rateLimitData[ip]; let needsSaveLimit = false; let effectiveLimit = ipData?.limit === 0 ? 0 : (ipData?.limit ?? global.currentDailyLimit); if (!ipData || now >= ipData.resetTime) { const currentSpecificLimit = ipData?.limit; rateLimitData[ip] = { count: 1, resetTime: calculateNextResetTime(), limit: currentSpecificLimit ?? null }; ipData = rateLimitData[ip]; needsSaveLimit = true; effectiveLimit = ipData.limit ?? global.currentDailyLimit; } else { if (effectiveLimit !== 0) { if (ipData.count >= effectiveLimit) { log.warn(`IP LIMIT: IP ${ip} limit tercapai (${ipData.count}/${effectiveLimit}).`); return res.status(429).json({ status: false, error: `Limit request harian (${effectiveLimit}) untuk IP Anda telah tercapai.` }); } ipData.count++; needsSaveLimit = true; } else { ipData.count++; needsSaveLimit = true; } } if (needsSaveLimit) saveRateLimits(); limitInfo = `ğŸ“Š <b>Limit IP:</b> ${ipData.count} / ${effectiveLimit === 0 ? 'âˆ' : effectiveLimit}`; } else { limitInfo = `âš¡ <b>Limit IP:</b> Unlimited (OFF)`; } }

    // [MODIFIKASI] Cek IP Unik & Notifikasi dengan IP Masked
    if (!global.uniqueIps.has(ip)) {
        global.uniqueIps.add(ip);
        saveUniqueIps();
        log.ipLog(`IP LOG: IP unik baru terdeteksi dan disimpan: ${ip}`);
        sendTelegramNotification(`ğŸ†• IP Unik Baru:\nIP: <code>${ip}</code>\nPath: ${reqPath}`);
        // Gunakan fungsi maskIp di sini
        addNotification('newUser', `Pengguna baru terdeteksi dari IP ${maskIp(ip)}`, 'user-plus');
    }

    sendTelegramNotification(`ğŸš€ <b>Request API</b> ğŸš€\nâ€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\nğŸ‘¤ <b>IP:</b> <code>${ip}</code>\nğŸ“ <b>Path:</b> ${reqPath}\n${limitInfo}`);
    next();
});
log.info("LOG: Middleware 2 (Logika Utama: Limit, API Key, IP Unik) dimuat.");

// Middleware format JSON
app.use((req, res, next) => { const originalJson = res.json; res.json = function(data) { if (data && typeof data === 'object' && data.status !== undefined) { const enhancedData = { creator: global.settings.creator || "Rikishopreal", ...data }; return originalJson.call(this, enhancedData); } return originalJson.call(this, data); }; next(); });
log.info("LOG: Middleware response JSON dimuat.");

// --- Load dynamic routes --- (Kode tetap sama)
let totalRoutes = 0; const apiFolder = path.join(__dirname, './src'); try { fs.readdirSync(apiFolder).forEach((subfolder) => { const subfolderPath = path.join(apiFolder, subfolder); if (fs.statSync(subfolderPath).isDirectory()) { fs.readdirSync(subfolderPath).forEach((file) => { if (path.extname(file) === '.js') { try { require(path.join(subfolderPath, file))(app, log); totalRoutes++; } catch (loadError) { log.error(`-> GAGAL load rute: ${subfolder}/${file}. Err: ${loadError.message}`); if (loadError.stack) { console.error(loadError.stack); } } } }); } }); log.info(`LOG: Selesai load rute dinamis. Total endpoint files: ${totalRoutes}`); } catch (readDirError) { log.error(`FATAL ERROR: Gagal baca folder src: ${readDirError.message}`); process.exit(1); }


// --- Public Endpoints --- (Kode endpoint tetap sama, hanya /api/stats yang sudah dimodif sebelumnya)
app.get('/', (req, res) => res.sendFile(path.join(__dirname, 'index.html')));
app.get('/api/endpoint-status', (req, res) => res.json({ status: true, creator: global.settings.creator, data: global.endpointStatus }));
app.get('/api/public/blacklist', (req, res) => res.json({ status: true, creator: global.settings.creator, blacklist: Array.from(global.ipBlacklist).sort() }));
app.get('/api/stats', (req, res) => res.json({ totalRequests: global.totalreq, uptime: runtime(), uniqueVisitorCount: global.uniqueIps.size, limit: global.currentDailyLimit }));
app.get('/api/my-stats', (req, res) => { const ip = req.ip; const ipData = rateLimitData[ip]; const effectiveLimit = ipData?.limit === 0 ? 0 : (ipData?.limit ?? global.currentDailyLimit); const resetTime = ipData?.resetTime || calculateNextResetTime(); const count = ipData?.count || 0; res.json({ status: true, isLimitEnabled: global.isRateLimitingEnabled, limit: effectiveLimit === 0 ? 'Infinity' : effectiveLimit, used: count, remaining: effectiveLimit === 0 ? 'Infinity' : Math.max(0, effectiveLimit - count), resetTime: resetTime }); });
app.get('/api/get-endpoints', (req, res) => { try { let settingsCopy = JSON.parse(JSON.stringify(global.settings)); const now = Date.now(); for (const category in settingsCopy.endpoints) { if (Array.isArray(settingsCopy.endpoints[category])) { settingsCopy.endpoints[category].forEach(endpoint => { if (!endpoint.path) return; const basePath = endpoint.path.split('?')[0]; let isNewStatic = endpoint.dateAdded && (now - new Date(endpoint.dateAdded).getTime()) / 36e5 <= 24; const dynamicLabelData = global.dynamicLabels[basePath]; if (dynamicLabelData && now < dynamicLabelData.expires) { endpoint.dynamicLabel = dynamicLabelData.label; } else { if (dynamicLabelData) delete global.dynamicLabels[basePath]; if (isNewStatic) endpoint.dynamicLabel = "NEW"; } const pathOverride = global.apiKeyOverrides[basePath]; let finalRequiresKey; if (pathOverride !== undefined) { finalRequiresKey = pathOverride; } else { finalRequiresKey = global.initialRequiredKeyPaths.has(basePath); } endpoint.requiresKey = finalRequiresKey; const originalPath = endpoint.path; const originalQuery = originalPath.split('?')[1] || ''; let displayParams = []; if (originalQuery) { const params = new URLSearchParams(originalQuery); for (const [key, value] of params.entries()) { if (key !== 'apikey' && key !== 'apikey_custom' && value !== '') { displayParams.push(`${key}=`); } else if (key !== 'apikey' && key !== 'apikey_custom') { displayParams.push(`${key}=`); } } } if (endpoint.requiresKey) { displayParams.push('apikey='); } endpoint.path = basePath; if (displayParams.length > 0) { endpoint.path += '?' + displayParams.join('&'); } }); } } res.json(settingsCopy); } catch (error) { log.error("Error generating /api/get-endpoints:", error); res.status(500).json({ status: false, error: "Internal server error processing endpoint data." }); }});
app.get('/api/notifications', (req, res) => { const sinceTimestamp = parseInt(req.query.since, 10) || 0; const unreadOnly = req.query.unread === 'true'; let filteredNotifications = global.notifications; if (sinceTimestamp > 0) { filteredNotifications = filteredNotifications.filter(n => n.timestamp > sinceTimestamp); } if (unreadOnly) { filteredNotifications = filteredNotifications.filter(n => !n.read); } res.json({ status: true, notifications: filteredNotifications, serverTime: Date.now() }); });
log.info("LOG: Rute publik dikonfigurasi.");


// --- Admin Endpoints --- (Kode admin endpoint tetap sama, notifikasi sudah ditambahkan sebelumnya)
app.get('/admin', (req, res) => { const loginPath = path.join(ROOT_DIR, 'login.html'); fs.access(loginPath, fs.constants.F_OK, (err) => { if (err) { log.error("ERROR: File login.html tidak ditemukan!"); return res.status(404).send("File login.html tidak ditemukan."); } res.sendFile(loginPath); }); });
app.post('/api/admin/login', (req, res) => { const { password } = req.body; if (!ADMIN_PAGE_PASSWORD) { log.error("ADMIN LOGIN GAGAL: ADMIN_PAGE_PASSWORD tidak diatur."); return res.status(500).json({ status: false, error: "Server login tidak dikonfigurasi." }); } if (!ADMIN_API_KEY) { log.error("ADMIN LOGIN GAGAL: ADMIN_KEY (API) tidak diatur."); return res.status(500).json({ status: false, error: "Server admin tidak dikonfigurasi." }); } if (password === ADMIN_PAGE_PASSWORD) { log.admin(`ADMIN LOGIN SUKSES dari IP: ${req.ip}`); res.json({ status: true, message: "Login success", token: ADMIN_API_KEY }); } else { log.warn(`ADMIN LOGIN GAGAL dari IP: ${req.ip}`); res.status(401).json({ status: false, error: "Password salah." }); } });
app.get('/admin-panel', (req, res) => { const adminPanelPath = path.join(ROOT_DIR, 'admin-panel.html'); fs.access(adminPanelPath, fs.constants.F_OK, (err) => { if (err) { log.error("ERROR: File admin-panel.html tidak ditemukan!"); return res.status(404).send("File admin-panel.html tidak ditemukan."); } res.sendFile(adminPanelPath); }); });
const adminAuthMiddleware = (req, res, next) => { const providedKey = req.method === 'GET' ? req.query.apikey : req.body.apikey; if (!ADMIN_API_KEY) { log.warn(`ADMIN AUTH FAIL: ADMIN_KEY tidak diset di server.`); return res.status(503).json({ status: false, error: "Fitur admin dinonaktifkan di server." }); } if (providedKey !== ADMIN_API_KEY) { log.warn(`ADMIN AUTH FAIL: Kunci tidak valid dari IP ${req.ip}`); return res.status(403).json({ status: false, error: "Admin API Key tidak valid." }); } next(); };
app.get('/api/admin/endpoints/list', adminAuthMiddleware, (req, res) => { try { const allPaths = new Set(); for (const category in global.settings.endpoints) { if (Array.isArray(global.settings.endpoints[category])) { global.settings.endpoints[category].forEach(e => { if (e.path) { allPaths.add(e.path.split('?')[0]); } }); } } const sortedPaths = Array.from(allPaths).sort(); res.json({ status: true, paths: sortedPaths }); } catch (err) { log.error("Error /api/admin/endpoints/list:", err); res.status(500).json({ status: false, error: "Internal server error saat mengambil list endpoint" }); } });
app.get('/api/admin/customkeys/list', adminAuthMiddleware, (req, res) => { const now = Date.now(); const keyList = Object.entries(global.customApiKeys).map(([key, data]) => ({ key: key, name: data.name, limit: data.limit, count: data.count || 0, expires: data.expires, isExpired: data.expires ? now >= data.expires : false, isOutOfLimit: data.limit > 0 ? (data.count || 0) >= data.limit : false, createdAt: data.createdAt })); keyList.sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0)); res.json({ status: true, keys: keyList }); });
app.post('/api/admin/customkeys/add', adminAuthMiddleware, (req, res) => { const { name, limit, days, key } = req.body; if (!name || typeof name !== 'string' || name.trim() === '') { return res.status(400).json({ status: false, error: "Nama kunci diperlukan." }); } if (!key || typeof key !== 'string' || key.trim() === '') { return res.status(400).json({ status: false, error: "API Key diperlukan." }); } const newKey = key.trim(); if (global.customApiKeys[newKey]) { return res.status(400).json({ status: false, error: `API Key '${newKey}' sudah ada.` }); } if (newKey.startsWith('RIKI-')) { return res.status(400).json({ status: false, error: "API Key tidak boleh diawali 'RIKI-'." }); } const parsedLimit = parseInt(limit, 10); if (isNaN(parsedLimit) || parsedLimit < 0) { return res.status(400).json({ status: false, error: "Limit harus angka 0 atau lebih (0 = unlimited)." }); } const parsedDays = parseInt(days, 10); if (isNaN(parsedDays) || parsedDays <= 0) { return res.status(400).json({ status: false, error: "Masa aktif (hari) harus angka positif." }); } const expiryTimestamp = moment().add(parsedDays, 'days').valueOf(); global.customApiKeys[newKey] = { name: name.trim(), limit: parsedLimit, count: 0, expires: expiryTimestamp, createdAt: Date.now() }; saveCustomApiKeys(); if (!global.apikey.includes(newKey)) { global.apikey.push(newKey); log.admin(`ADMIN: Kunci ${newKey} ditambahkan ke global.apikey (in-memory).`); } log.admin(`ADMIN: Kunci kustom baru ditambahkan: ${name.trim()} (${newKey}), Limit: ${parsedLimit}, Aktif: ${parsedDays} hari.`); sendTelegramNotification(`ğŸ”‘ Kunci Kustom Baru:\nNama: ${name.trim()}\nKunci: <code>${newKey}</code>\nLimit: ${parsedLimit === 0 ? 'Unlimited' : parsedLimit}\nMasa Aktif: ${parsedDays} hari`); addNotification('adminAction', `Kunci API kustom '${name.trim()}' ditambahkan.`, 'key'); res.json({ status: true, message: `Kunci '${name.trim()}' (${newKey}) berhasil dibuat.`, newKey: newKey }); });
app.post('/api/admin/customkeys/delete', adminAuthMiddleware, (req, res) => { const { key } = req.body; if (!key || typeof key !== 'string' || !global.customApiKeys[key]) { return res.status(400).json({ status: false, error: "Kunci tidak valid atau tidak ditemukan." }); } const keyName = global.customApiKeys[key].name || key; delete global.customApiKeys[key]; saveCustomApiKeys(); const index = global.apikey.indexOf(key); if (index > -1) { global.apikey.splice(index, 1); log.admin(`ADMIN: Kunci ${key} dihapus dari global.apikey (in-memory).`); } log.admin(`ADMIN: Kunci kustom dihapus: ${keyName} (${key}).`); sendTelegramNotification(`ğŸ—‘ï¸ Kunci Kustom Dihapus:\nNama: ${keyName}\nKunci: <code>${key}</code>`); addNotification('adminAction', `Kunci API kustom '${keyName}' dihapus.`, 'trash-alt'); res.json({ status: true, message: `Kunci '${keyName}' berhasil dihapus.` }); });
app.post('/api/admin/set-label', adminAuthMiddleware, (req, res) => { const { endpoint, label } = req.body; const validLabels = ["NEW", "FIX", ""]; if (!endpoint || !validLabels.includes(label)) { return res.status(400).json({ status: false, error: "Parameter 'endpoint' (path) dan 'label' (NEW/FIX/'') diperlukan." }); } let endpointExists = Object.values(global.settings.endpoints).flat().some(e => e.path?.startsWith(endpoint)); if (!endpointExists) { return res.status(404).json({ status: false, error: `Endpoint path '${endpoint}' tidak ditemukan di settings.` }); } if (label === "") { if (global.dynamicLabels[endpoint]) { delete global.dynamicLabels[endpoint]; log.admin(`ADMIN: Label dinamis untuk ${endpoint} dihapus.`); addNotification('endpointUpdate', `Label untuk endpoint ${endpoint} dihapus.`, 'tag'); res.json({ status: true, message: `Label dinamis untuk ${endpoint} berhasil dihapus.` }); } else { res.json({ status: true, message: `Endpoint ${endpoint} tidak memiliki label dinamis.` }); } } else { global.dynamicLabels[endpoint] = { label: label, expires: Date.now() + 86400000 }; log.admin(`ADMIN: Label dinamis '${label}' diatur untuk ${endpoint} selama 24 jam.`); addNotification('endpointUpdate', `Endpoint ${endpoint} diberi label '${label}'.`, 'tags'); res.json({ status: true, message: `Label '${label}' berhasil diatur untuk ${endpoint} (berlaku 24 jam).` }); } });
app.get('/api/admin/blacklist/list', adminAuthMiddleware, (req, res) => res.json({ status: true, blacklist: Array.from(global.ipBlacklist).sort() }));
app.post('/api/admin/blacklist/add', adminAuthMiddleware, (req, res) => { const { ip } = req.body; if (!ip || typeof ip !== 'string' || ip.trim() === '') { return res.status(400).json({ status: false, error: "Parameter 'ip' diperlukan." }); } const ipToAdd = ip.trim(); if (global.ipBlacklist.has(ipToAdd)) { return res.json({ status: true, message: `IP ${ipToAdd} sudah ada di blacklist.` }); } global.ipBlacklist.add(ipToAdd); saveBlacklist(); log.admin(`ADMIN: IP ${ipToAdd} ditambahkan ke blacklist.`); sendTelegramNotification(`ğŸš« IP Ditambahkan ke Blacklist (Manual):\nIP: <code>${ipToAdd}</code>`); addNotification('adminAction', `IP ${maskIp(ipToAdd)} ditambahkan ke blacklist.`, 'user-slash'); res.json({ status: true, message: `IP ${ipToAdd} berhasil ditambahkan ke blacklist.` }); }); // [MODIFIKASI] Gunakan maskIp
app.post('/api/admin/blacklist/remove', adminAuthMiddleware, (req, res) => { const { ip } = req.body; if (!ip || typeof ip !== 'string' || ip.trim() === '') { return res.status(400).json({ status: false, error: "Parameter 'ip' diperlukan." }); } const ipToRemove = ip.trim(); if (!global.ipBlacklist.has(ipToRemove)) { return res.json({ status: true, message: `IP ${ipToRemove} tidak ditemukan di blacklist.` }); } global.ipBlacklist.delete(ipToRemove); saveBlacklist(); log.admin(`ADMIN: IP ${ipToRemove} dihapus dari blacklist.`); sendTelegramNotification(`âœ… IP Dihapus dari Blacklist (Manual):\nIP: <code>${ipToRemove}</code>`); addNotification('adminAction', `IP ${maskIp(ipToRemove)} dihapus dari blacklist.`, 'user-check'); res.json({ status: true, message: `IP ${ipToRemove} berhasil dihapus dari blacklist.` }); }); // [MODIFIKASI] Gunakan maskIp
app.get('/api/admin/limit/status', adminAuthMiddleware, (req, res) => res.json({ status: true, enabled: global.isRateLimitingEnabled, globalLimit: global.currentDailyLimit }));
app.post('/api/admin/limit/toggle', adminAuthMiddleware, (req, res) => { const { enable } = req.body; if (typeof enable !== 'boolean') { return res.status(400).json({ status: false, error: "Parameter 'enable' harus boolean (true/false)." }); } global.isRateLimitingEnabled = enable; const statusText = enable ? 'DIAKTIFKAN' : 'DINONAKTIFKAN'; log.admin(`ADMIN: Rate Limit IP Global -> ${statusText}.`); sendTelegramNotification(`âš ï¸ Rate Limit Global (IP) -> ${statusText}`); addNotification('adminAction', `Rate Limit IP Global ${statusText}.`, 'tachometer-alt'); res.json({ status: true, message: `Rate limit IP Global berhasil ${statusText}.`, enabled: enable }); });
app.post('/api/admin/limit/set-global', adminAuthMiddleware, (req, res) => { const limitInput = req.body.newLimit; const newLimitNum = parseInt(limitInput, 10); if (isNaN(newLimitNum) || newLimitNum < 0) { return res.status(400).json({ status: false, error: "Parameter 'newLimit' harus berupa angka 0 atau lebih." }); } const oldLimit = global.currentDailyLimit; global.currentDailyLimit = newLimitNum; const limitText = newLimitNum === 0 ? 'Unlimited' : newLimitNum; log.admin(`ADMIN: Global Limit IP diubah menjadi -> ${limitText}.`); sendTelegramNotification(`âš™ï¸ Global Limit (IP) Diubah:\nSebelumnya: ${oldLimit === 0 ? 'Unlimited' : oldLimit}\nMenjadi: ${limitText}`); addNotification('adminAction', `Global Limit IP diubah menjadi ${limitText}.`, 'cogs'); res.json({ status: true, message: `Global Limit IP berhasil diubah menjadi ${limitText}.`, newLimit: newLimitNum }); });
app.post('/api/admin/limit/set-ip', adminAuthMiddleware, (req, res) => { const { ip, newLimit } = req.body; const limitNum = parseInt(newLimit, 10); if (!ip || typeof ip !== 'string' || ip.trim() === '') { return res.status(400).json({ status: false, error: "Parameter 'ip' diperlukan." }); } if (isNaN(limitNum) || limitNum < 0) { return res.status(400).json({ status: false, error: "Parameter 'newLimit' harus berupa angka 0 atau lebih (0 = unlimited)." }); } const targetIp = ip.trim(); if (!rateLimitData[targetIp]) { rateLimitData[targetIp] = { count: 0, resetTime: calculateNextResetTime(), limit: limitNum }; } else { rateLimitData[targetIp].limit = limitNum; } saveRateLimits(); const limitText = limitNum === 0 ? 'UNLIMITED' : limitNum; log.admin(`ADMIN: Limit untuk IP ${targetIp} diubah menjadi -> ${limitText}.`); sendTelegramNotification(`ğŸ”§ Limit IP Spesifik Diubah:\nIP: <code>${targetIp}</code>\nLimit Baru: ${limitText}`); addNotification('adminAction', `Limit untuk IP ${maskIp(targetIp)} diubah menjadi ${limitText}.`, 'sliders-h'); res.json({ status: true, message: `Limit untuk IP ${targetIp} berhasil diubah menjadi ${limitText}.` }); }); // [MODIFIKASI] Gunakan maskIp
app.get('/api/admin/limit/all-ips', adminAuthMiddleware, (req, res) => { const now = Date.now(); try { if (typeof rateLimitData !== 'object' || rateLimitData === null) { log.error("Error /api/admin/limit/all-ips: rateLimitData bukan object valid. Resetting."); rateLimitData = {}; } const allIpData = Object.entries(rateLimitData) .map(([ip, data]) => { try { if (typeof data !== 'object' || data === null) { log.warn(`Peringatan: Data untuk IP ${ip} di rate_limits.json tidak valid, dilewati.`); return null; } const limitValue = data.limit; const countValue = data.count || 0; const resetTimeValue = data.resetTime || calculateNextResetTime(); const effectiveLimit = limitValue === 0 ? 0 : (limitValue ?? global.currentDailyLimit); const isExpired = now >= resetTimeValue; const currentCount = isExpired ? 0 : countValue; let limitDisplay = (effectiveLimit === 0) ? `Used: ${currentCount}` : `${currentCount} / ${effectiveLimit}`; let specificLimitDisplay = 'Global'; if (limitValue === 0) specificLimitDisplay = 'Unlimited (IP)'; else if (limitValue !== null && limitValue !== undefined) specificLimitDisplay = `${limitValue} (IP)`; return { ip: ip, usageDisplay: limitDisplay, specificLimitDisplay: specificLimitDisplay, resetTime: resetTimeValue, resetsInMs: Math.max(0, resetTimeValue - now), isExpired: isExpired }; } catch (innerErr) { log.error(`Error saat memproses IP ${ip} di /api/admin/limit/all-ips:`, innerErr); return null; } }) .filter(item => item !== null); allIpData.sort((a, b) => a.isExpired - b.isExpired || a.resetsInMs - b.resetsInMs); res.json({ status: true, ipData: allIpData }); } catch (err) { log.error("Error /api/admin/limit/all-ips:", err); res.status(500).json({ status: false, error: "Internal server error saat mengambil data IP." }); } });
app.get('/api/admin/apikey-requirements/list', adminAuthMiddleware, (req, res) => { try { const statusList = []; const allPaths = new Set(); for (const category in global.settings.endpoints) { if (Array.isArray(global.settings.endpoints[category])) { global.settings.endpoints[category].forEach(e => { if (e.path) { allPaths.add(e.path.split('?')[0]); } }); } } const sortedPaths = Array.from(allPaths).sort(); sortedPaths.forEach(path => { const initial = global.initialRequiredKeyPaths.has(path); const override = global.apiKeyOverrides[path]; let current = initial; if (override !== undefined) { current = override; } statusList.push({ path: path, initial: initial, current: current }); }); res.json({ status: true, requirements: statusList }); } catch (err) { log.error("Error /api/admin/apikey-requirements/list:", err); res.status(500).json({ status: false, error: "Internal server error saat memproses status API Key." }); } });
app.post('/api/admin/apikey-requirements/set', adminAuthMiddleware, (req, res) => { const { path, require } = req.body; if (!path || typeof require !== 'boolean') { return res.status(400).json({ status: false, error: "Parameter 'path' (string) dan 'require' (boolean) diperlukan." }); } let found = false; for (const category in global.settings.endpoints) { if (Array.isArray(global.settings.endpoints[category])) { if (global.settings.endpoints[category].some(e => e.path?.startsWith(path))) { found = true; break; } } } if (!found) { return res.status(404).json({ status: false, error: `Endpoint path '${path}' tidak ditemukan di settings.json.` }); } const initialRequirement = global.initialRequiredKeyPaths.has(path); const statusText = require ? 'WAJIB' : 'PUBLIK'; if (require === initialRequirement) { if (global.apiKeyOverrides[path] !== undefined) { delete global.apiKeyOverrides[path]; saveApiKeyOverrides(); log.admin(`ADMIN: Override API Key untuk ${path} dihapus (kembali ke default: ${initialRequirement ? 'WAJIB' : 'PUBLIK'}).`); sendTelegramNotification(`ğŸ”‘ Aturan API Key Dikembalikan:\nPath: ${path}\nStatus: Kembali ke Default (${initialRequirement ? 'WAJIB' : 'PUBLIK'})`); addNotification('adminAction', `Aturan API Key untuk ${path} dikembalikan ke default.`, 'undo'); res.json({ status: true, message: `Aturan API Key untuk ${path} berhasil dikembalikan ke default.` }); } else { res.json({ status: true, message: `Aturan API Key untuk ${path} sudah sesuai default (${statusText}), tidak ada perubahan.` }); } } else { global.apiKeyOverrides[path] = require; saveApiKeyOverrides(); log.admin(`ADMIN: Override API Key untuk ${path} diatur menjadi ${statusText}.`); sendTelegramNotification(`ğŸ”‘ Aturan API Key Diubah:\nPath: ${path}\nStatus: Diubah menjadi ${statusText}`); addNotification('adminAction', `Aturan API Key untuk ${path} diubah menjadi ${statusText}.`, 'edit'); res.json({ status: true, message: `Aturan API Key untuk ${path} berhasil diubah menjadi ${statusText}.` }); } });
log.info("LOG: Rute admin dikonfigurasi.");

// --- Error Handlers & Server Start --- (Kode tetap sama)
app.use((req, res, next) => { fs.access(error404Path, fs.constants.F_OK, (err) => { if (!err) res.status(404).sendFile(error404Path); else res.status(404).send('404 Not Found'); }); });
app.use((err, req, res, next) => { log.error("ERROR HANDLER 500:", err.stack || err); if (req.path && global.endpointStatus[req.path]) { global.endpointStatus[req.path] = 'Error'; log.warn(`ENDPOINT STATUS: ${req.path} diubah menjadi Error karena exception.`); } fs.access(error500Path, fs.constants.F_OK, (errAccess) => { if (!errAccess) res.status(500).sendFile(error500Path); else res.status(500).send('500 Internal Server Error'); }); });
const server = app.listen(PORT, '0.0.0.0', () => { const host = global.settings.publicAddress || 'localhost'; console.log(chalk.blue(` Server BERHASIL berjalan di http://${host}:${PORT} `)); console.log(chalk.yellow(` Halaman Login Admin: http://${host}:${PORT}/admin `)); addNotification('system', 'Server API berhasil dimulai.', 'power-off'); });
server.on('error', (error) => { log.error('FATAL ERROR server! ğŸ’¥', error); addNotification('system', `Server GAGAL dimulai: ${error.message}`, 'exclamation-triangle'); process.exit(1); });
process.on('uncaughtException', (err) => { log.error('UNCAUGHT EXCEPTION! ğŸ’¥', err); addNotification('system', `Uncaught Exception: ${err.message}`, 'bug'); if (err.stack) console.error(err.stack); });
process.on('unhandledRejection', (reason, promise) => { log.error('UNHANDLED REJECTION! ğŸ’¥', reason); addNotification('system', `Unhandled Rejection: ${reason}`, 'bomb'); if (reason && reason.stack) console.error(reason.stack); });

